---
title: "Joined_bee_ws_gt_analysis"
author: "Liliana_Lay"
date: "2025-08-01"
output: html_document
---

```{r}
#attempt at running a step-wise regression on fully merged data
#This code follow methods provided in this paper:
#CORBET, S.A., FUSSELL, M., AKE, R., FRASER, A., GUNSON, C., SAVAGE, A. and SMITH, K. (1993), Temperature and the pollinating activity of social bees. Ecological Entomology, 18: 17-30. https://doi.org/10.1111/j.1365-2311.1993.tb01075.

library(dplyr)
library(lubridate)
library(MASS)

# Prepare data
bee_model_data <- joined_bee_ws_gt_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime) + minute(bee_exit_datetime)/60,
    skyc1 = as.factor(skyc1)
  ) %>%
  filter(!is.na(tmpf), !is.na(ground_temperature_F), !is.na(relh), !is.na(skyc1))

bee_model_data$skyc1 <- relevel(bee_model_data$skyc1, ref = "CLR")

# Full model
full_model <- lm(exit_hour ~ ground_temperature_F + tmpf + relh + skyc1, data = bee_model_data)

# Stepwise selection
step_model <- step(full_model, direction = "both")

# View model
summary(step_model)

levels(bee_model_data$skyc1)

```

```{r}
#code to run a mixed effects model with date as the random effect and change cloud categories to just clear and cloudy 

library(dplyr)
library(lubridate)
library(lme4)
library(ggplot2)

# Step 1: Recode sky condition and prepare data
bee_model_data <- joined_bee_ws_gt_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60,
    date = as.Date(bee_exit_datetime),
    cloud_condition = case_when(
      skyc1 == "CLR" ~ "Clear",
      !is.na(skyc1) ~ "Cloudy",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(
    !is.na(ground_temperature_F),
    !is.na(tmpf),
    !is.na(relh),
    !is.na(cloud_condition),
    !is.na(exit_hour),
    !is.na(date)
  )

# Convert cloud_condition to a factor and set "Clear" as the reference level
bee_model_data$cloud_condition <- factor(bee_model_data$cloud_condition, levels = c("Clear", "Cloudy"))

# Step 2: Fit mixed effects model with all predictors
mixed_model <- lmer(exit_hour ~ ground_temperature_F + tmpf + relh + cloud_condition + (1 | date),
                    data = bee_model_data)

# Step 3: View model results
summary(mixed_model)

# Step 4: Add predicted values back to the dataset
bee_model_data$predicted_exit_hour <- predict(mixed_model)

#step 5 to calculate marginal and conditional R^2 values


install.packages("MuMIn")
library(MuMIn)
r.squaredGLMM(mixed_model)

#lets plot the model based on JT Miller's suggestion
library(effects)
plot(allEffects(mixed_model))

```


```{r}
#code to plot a bee exit density plot over time

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lubridate)

# Step 1: Extract the time of day in decimal hour
density_plot_data <- joined_bee_ws_gt_data %>%
  filter(!is.na(bee_exit_datetime)) %>%
  mutate(
    decimal_hour = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60
  )

# Step 2: Create the density plot
ggplot(density_plot_data, aes(x = decimal_hour)) +
  geom_density(fill = "maroon2", alpha = 0.6, adjust = 1.2) +
  labs(
    title = "Density of Bee Exits Over Time",
    x = "Hour of Day",
    y = "Density of Bee Exits"
  ) +
  scale_x_continuous(breaks = seq(7, 17, 1)) +
  theme_minimal(base_size = 14)

```

```{r}
#script to see how ground temperature changes over time, colored by cloud cover (clear/cloudy)

library(dplyr)
library(ggplot2)
library(lubridate)

# Step 1: Create time-of-day and cloud_condition columns
plot_data <- joined_bee_ws_gt_data %>%
  mutate(
    # Convert full datetime to time-of-day (ignores date)
    time_of_day = as.POSIXct(format(datetime_ground_temp, format = "%H:%M:%S"), format = "%H:%M:%S"),
    
    # Simplify sky cover to "Clear" vs "Cloudy"
    cloud_condition = case_when(
      skyc1 == "CLR" ~ "Clear",
      !is.na(skyc1) ~ "Cloudy",
      TRUE ~ NA_character_
    ),
    cloud_condition = factor(cloud_condition, levels = c("Clear", "Cloudy"))
  ) %>%
  filter(!is.na(time_of_day), !is.na(ground_temperature_F), !is.na(cloud_condition))

# Step 2: Calculate R² for each sky condition
rsq_labels <- plot_data %>%
  group_by(cloud_condition) %>%
  summarise(
    rsq = summary(lm(ground_temperature_F ~ as.numeric(time_of_day)))$r.squared,
    x = min(time_of_day, na.rm = TRUE),
    y = max(ground_temperature_F, na.rm = TRUE) - 2 * as.numeric(as.factor(cloud_condition))  # offsets the labels
  ) %>%
  mutate(label = paste0("R² = ", round(rsq, 3)))

# Step 3: Plot
ggplot(plot_data, aes(x = time_of_day, y = ground_temperature_F, color = cloud_condition)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 1) +
  geom_text(data = rsq_labels, aes(x = x, y = y, label = label, color = cloud_condition), hjust = 0, show.legend = FALSE) +
  labs(
    title = "Ground Temperature Over Time of Day",
    x = "Time of Day",
    y = "Ground Temperature (°F)",
    color = "Sky Condition"
  ) +
  scale_x_datetime(
    date_labels = "%H:%M",
    date_breaks = "1 hour"
  ) +
  scale_size_continuous(range = c(2, 6)) +
  scale_color_manual(
    values = c("Clear" = "gold", "Cloudy" = "hotpink"),
    name = "Sky Condition"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```


```{r}



# Load required libraries
library(dplyr)
library(ggplot2)
library(lubridate)

# Step 1: Create decimal_hour and cloud_condition columns
plot_data <- joined_bee_ws_gt_data %>%
  filter(!is.na(datetime_ground_temp)) %>%
  mutate(
    # Decimal representation of hour (e.g., 13.5 = 1:30 PM)
    decimal_hour = hour(datetime_ground_temp) + minute(datetime_ground_temp) / 60,
    
    # Simplify sky cover to "Clear" vs "Cloudy"
    cloud_condition = case_when(
      skyc1 == "CLR" ~ "Clear",
      !is.na(skyc1) ~ "Cloudy",
      TRUE ~ NA_character_
    ),
    
    cloud_condition = factor(cloud_condition, levels = c("Clear", "Cloudy"))
  )

# Step 2: Calculate R² for each sky condition
rsq_labels <- plot_data %>%
  group_by(cloud_condition) %>%
  summarise(
    rsq = summary(lm(ground_temperature_F ~ decimal_hour))$r.squared,
    x = min(decimal_hour, na.rm = TRUE),
    y = max(ground_temperature_F, na.rm = TRUE) - 2 * as.numeric(as.factor(cloud_condition)),  # offset label vertically
    .groups = "drop"
  ) %>%
  mutate(label = paste0("R² = ", round(rsq, 3)))

# Step 3: Plot
ggplot(plot_data, aes(x = decimal_hour, y = ground_temperature_F, color = cloud_condition)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 1) +
  geom_text(data = rsq_labels, aes(x = x, y = y, label = label, color = cloud_condition),
            hjust = 0, show.legend = FALSE) +
  labs(
    title = "Ground Temperature Over Time of Day (Decimal Hour)",
    x = "Hour of Day (Decimal)",
    y = "Ground Temperature (°F)",
    color = "Sky Condition"
  ) +
  scale_x_continuous(breaks = seq(7, 17, 1)) +
  scale_color_manual(
    values = c("Clear" = "gold", "Cloudy" = "hotpink"),
    name = "Sky Condition"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5)
  )


```





```{r}
#graph to model the differences between the exit times predicted by the model and the actual bee exit times. Shows how well the model is working

library(dplyr)
library(ggplot2)

# Step 1: Create a decimal exit hour from datetime
bee_model_data <- bee_model_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60
  )

# Step 2: Generate predicted values from the model (assuming `step_model` already exists)
bee_model_data <- bee_model_data %>%
  mutate(
    predicted_exit = predict(step_model, newdata = .),
    residual = exit_hour - predicted_exit
  )

# Step 3: Plot residuals
ggplot(bee_model_data, aes(x = predicted_exit, y = residual)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_point(alpha = 0.6, color = "hotpink") +
  geom_smooth(method = "loess", se = TRUE, color = "skyblue") +
  labs(
    title = "Residuals: Actual vs. Predicted Bee Exit Times",
    x = "Predicted Bee Exit Time (Hour)",
    y = "Residual (Actual - Predicted)"
  ) +
  theme_minimal(base_size = 13) +
  scale_x_continuous(breaks = pretty(bee_model_data$predicted_exit, n = 6)) +
  scale_y_continuous(breaks = pretty(bee_model_data$residual, n = 6))


```




```{r}
#This code will try and plot some visualizations based on what model predicted above

#This code will show the average predicted time by cloud cover category: "how does cloudiness shift the average emergence time?"

library(ggplot2)

# Create new data frame for prediction
pred_data <- bee_model_data %>%
  group_by(skyc1) %>%
  summarise(across(c(ground_temperature_F, tmpf, relh), mean)) %>%
  mutate(predicted_exit = predict(step_model, newdata = .))

# Plot
ggplot(pred_data, aes(x = skyc1, y = predicted_exit)) +
  geom_col(fill = "steelblue") +
  labs(
    title = "Predicted Bee Exit Time by Cloud Cover",
    x = "Cloud Cover (skyc1)",
    y = "Predicted Exit Hour"
  ) +
  theme_minimal()



#lines of predicted exit time vs. ground temperature, split across cloud categories.

library(ggplot2)
library(dplyr)

# Create a sequence of ground temperatures
temp_seq <- seq(
  from = min(bee_model_data$ground_temperature_F, na.rm = TRUE),
  to   = max(bee_model_data$ground_temperature_F, na.rm = TRUE),
  length.out = 100
)

# Create prediction grid with mean values for other predictors
predict_grid <- expand.grid(
  ground_temperature_F = temp_seq,
  tmpf  = mean(bee_model_data$tmpf, na.rm = TRUE),
  relh  = mean(bee_model_data$relh, na.rm = TRUE),
  skyc1 = levels(bee_model_data$skyc1)
)

# Predict exit time
predict_grid$predicted_exit <- predict(step_model, newdata = predict_grid)

# Plot
ggplot(predict_grid, aes(x = ground_temperature_F, y = predicted_exit)) +
  geom_line() +
  facet_wrap(~ skyc1) +
  labs(
    title = "Effect of Temperature on Predicted Bee Exit Time",
    x = "Ground Temperature (°F)",
    y = "Predicted Exit Hour"
  ) +
  theme_minimal()




```
```{r}
#graph to plot time vs bee exits for the multiple days

library(dplyr)
library(lubridate)
library(ggplot2)

# Step 1: Prepare hourly bee exit counts
bee_hourly <- joined_bee_ws_gt_data %>%
  mutate(
    date = as.Date(bee_exit_datetime),
    hour = hour(bee_exit_datetime) + minute(bee_exit_datetime)/60  # decimal time
  ) %>%
  group_by(date, hour = floor(hour)) %>%
  summarise(n_exits = n(), .groups = "drop")

# Step 2: Plot with LOESS smoothing
ggplot(bee_hourly, aes(x = hour, y = n_exits, group = date, color = as.factor(date))) +
  geom_smooth(se = FALSE, method = "loess", span = 0.6, linewidth = 1.2) +
  scale_x_continuous(
    name = "Time of Day (Hour)",
    breaks = seq(9, 14, by = 1),  # Ticks from 6 AM to 6 PM
    limits = c(9, 14)
  ) +
  scale_y_continuous(name = "Number of Bee Exits (per Hour)") +
  labs(
    title = "Smoothed Bee Exit Activity by Time of Day",
    color = "Date"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )


#plotting average temperature change vs. Average predicted bee exit time (based off model)

library(dplyr)
library(ggplot2)

# Step 1: Extract hour from bee exit datetime
bee_model_data <- bee_model_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60,
    date = as.Date(bee_exit_datetime)
  )

# Step 2: Calculate average ground temp per date
avg_temp_per_day <- bee_model_data %>%
  group_by(date) %>%
  summarise(avg_ground_temp = mean(ground_temperature_F, na.rm = TRUE), .groups = "drop")

# Step 3: Join average ground temp back to original bee data
bee_plot_data <- bee_model_data %>%
  left_join(avg_temp_per_day, by = "date")

# Step 4: Plot
ggplot(bee_plot_data, aes(x = avg_ground_temp, y = predicted_exit)) +
  geom_jitter(width = 0.3, height = 0.2, alpha = 0.5, color = "hotpink") +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  labs(
    x = "Average Ground Temperature (°F)",
    y = "Bee Exit Time (Hour)",
    title = "Bee Exit Time vs. Daily Avg. Ground Temperature"
  ) +
  scale_x_continuous(breaks = pretty(bee_plot_data$avg_ground_temp, n = 6)) +
  scale_y_continuous(breaks = seq(7, 17, 1)) +
  theme_minimal(base_size = 13)




```


```{r}
#same thing as average ground temp vs average predicted bee exit time but color coded with cloud cover averages

library(dplyr)
library(ggplot2)

# Step 1: Predict exit time using the existing fitted model
bee_model_data$predicted_exit <- predict(step_model, newdata = bee_model_data)

# Step 2: Create summary data grouped by date and sky condition
summary_df <- bee_model_data %>%
  mutate(date = as.Date(bee_exit_datetime)) %>%
  group_by(date, skyc1) %>%
  summarise(
    avg_ground_temp = mean(ground_temperature_F, na.rm = TRUE),
    avg_predicted_exit = mean(predicted_exit, na.rm = TRUE),
    .groups = "drop"
  )

# Step 3: Plot with skyc1 as color
ggplot(summary_df, aes(x = avg_ground_temp, y = avg_predicted_exit, color = skyc1)) +
  geom_point(size = 3, alpha = 0.8) +
  labs(
    x = "Average Ground Temperature (°F)",
    y = "Average Predicted Bee Exit Time (Hour)",
    color = "Cloud Cover",
    title = "Predicted Bee Exit Time vs. Ground Temp by Cloud Cover"
  ) +
  scale_x_continuous(breaks = pretty(summary_df$avg_ground_temp, n = 6)) +
  scale_y_continuous(breaks = pretty(summary_df$avg_predicted_exit, n = 6)) +
  theme_minimal(base_size = 13)




```

```{r}
#code the graph time vs ground temp, colored by cloud cover and size of dots get bigger with more bee exits

library(dplyr)
library(ggplot2)
library(lubridate)

# Step 1: Add hour of exit and prepare relevant columns
plot_data <- joined_bee_ws_gt_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime),
    ground_temp = ground_temperature_F,
    skyc1 = as.factor(skyc1)
  ) %>%
  filter(!is.na(exit_hour), !is.na(ground_temp), !is.na(skyc1))

# Step 2: Count number of bees per (hour, temperature, sky condition)
summary_df <- plot_data %>%
  group_by(exit_hour, ground_temp, skyc1) %>%
  summarise(n_bees = n(), .groups = "drop")

# Step 3: Plot with color by sky condition and size by number of bees
ggplot(summary_df, aes(x = exit_hour, y = ground_temp)) +
  geom_point(aes(size = n_bees, color = skyc1), alpha = 0.7) +
  scale_size_continuous(name = "Number of Bees") +
  scale_color_brewer(palette = "Dark2", name = "Sky Cover") +
  labs(
    title = "Bee Exit Density by Hour, Ground Temp, and Sky Cover",
    x = "Hour of Day",
    y = "Ground Temperature (°F)"
  ) +
  scale_x_continuous(breaks = seq(7, 17, 1)) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 8)) +
  theme_minimal(base_size = 14)


```

```{r}
library(dplyr)
library(ggplot2)
library(lubridate)

# Step 1: Add hour of exit and prepare relevant columns
plot_data <- joined_bee_ws_gt_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime),
    ground_temp = ground_temperature_F,
    skyc1 = as.factor(skyc1),
    # New grouping: CLR, OVC, and "Other"
    sky_group = case_when(
      skyc1 == "CLR" ~ "Clear",
      skyc1 == "OVC" ~ "Overcast",
      TRUE ~ "Other"
    )
  ) %>%
  filter(!is.na(exit_hour), !is.na(ground_temp), !is.na(sky_group))

# Step 2: Count number of bees per (hour, temperature, sky group)
summary_df <- plot_data %>%
  group_by(exit_hour, ground_temp, sky_group) %>%
  summarise(n_bees = n(), .groups = "drop")

# Step 3: Plot with color by simplified sky condition and size by number of bees
ggplot(summary_df, aes(x = exit_hour, y = ground_temp)) +
  geom_point(aes(size = n_bees, color = sky_group), alpha = 0.7) +
  scale_size_continuous(name = "Number of Bees") +
  scale_color_manual(
    values = c("Clear" = "skyblue3", "Overcast" = "gray40", "Other" = "tan"),
    name = "Sky Cover"
  ) +
  labs(
    title = "Bee Exit Density by Hour, Ground Temp, and Simplified Sky Cover",
    x = "Hour of Day",
    y = "Ground Temperature (°F)"
  ) +
  scale_x_continuous(breaks = seq(7, 17, 1)) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 8)) +
  theme_minimal(base_size = 14)

```



```{r}
#same graph above but faceted

library(dplyr)
library(ggplot2)
library(lubridate)

# Step 1: Prepare data
plot_data <- joined_bee_ws_gt_data %>%
  mutate(
    exit_hour = hour(bee_exit_datetime),
    ground_temp = ground_temperature_F,
    skyc1 = as.factor(skyc1),
    date = as.Date(bee_exit_datetime)
  ) %>%
  filter(!is.na(exit_hour), !is.na(ground_temp), !is.na(skyc1), !is.na(date))

# Step 2: Count number of bee exits per combo
summary_df <- plot_data %>%
  group_by(date, exit_hour, ground_temp, skyc1) %>%
  summarise(n_bees = n(), .groups = "drop")

# Step 3: Plot with full axis labels in each facet
plot_bees <- ggplot(summary_df, aes(x = exit_hour, y = ground_temp)) +
  geom_point(aes(size = n_bees, color = skyc1), alpha = 0.7) +
  geom_smooth(aes(color = skyc1), method = "loess", se = FALSE, linewidth = 1, span = 1) +
  scale_size_continuous(name = "Bee Exits") +
  scale_color_brewer(palette = "Dark2", name = "Sky Cover") +
  labs(
    title = "Bee Exit Density by Hour, Ground Temp, and Sky Cover (Faceted by Day)",
    x = "Hour of Day",
    y = "Ground Temperature (°F)"
  ) +
  scale_x_continuous(breaks = seq(7, 17, 1)) +
  scale_y_continuous(breaks = scales::pretty_breaks(n = 6)) +
  facet_wrap(~date, scales = "fixed") +
  theme_minimal(base_size = 13) +
  theme(
    strip.text = element_text(size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.spacing = unit(1, "lines")
  )

#save graph
# Save as high-resolution PNG
ggsave(
  filename = "bee_exits_by_hour_temp_cloudcover.png",
  plot = plot_bees,                   # your ggplot object
  width = 12,                         # width in inches
  height = 8,                         # height in inches
  dpi = 300                           # print quality
)

# Save as a vector-based PDF (great for posters)
ggsave(
  filename = "bee_exits_by_hour_temp_cloudcover.pdf",
  plot = plot_bees,
  width = 12,
  height = 8,
  dpi = 300  # ignored for PDF but still required
)

print(summary_df)

```



```{r}
#how temperature changes over time by cloud cover

ggplot(joined_bee_ws_gt_data, aes(x = skyc1, y = ground_temperature_F, fill = skyc1)) +
  geom_boxplot() +
  labs(
    x = "Sky Condition",
    y = "Ground Temperature (°F)",
    title = "Ground Temperature by Sky Condition"
  ) +
  scale_fill_brewer(palette = "Dark2") +
  theme_minimal(base_size = 13)

```


```{r}
#code to re-run step-wise regression analysis with time as a factor
#using smoothing methods/moving window average

library(dplyr)
library(zoo)
library(lubridate)

# Define a mode function for categorical rolling window
get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

joined_bee_ws_gt_data_analysis <- joined_bee_ws_gt_data %>%
  arrange(datetime_ground_temp) %>%
  mutate(
    # Smoothed numeric variables using rolling average (width=3, centered)
    ground_temp_rollavg = rollapply(ground_temperature_F, width = 3, FUN = mean, align = "center", fill = NA),
    tmpf_rollavg = rollapply(tmpf, width = 3, FUN = mean, align = "center", fill = NA),
    relh_rollavg = rollapply(relh, width = 3, FUN = mean, align = "center", fill = NA),
    
    # Smoothed cloud cover: rolling mode (width=3, centered)
    skyc1_rollavg = rollapply(skyc1, width = 3, FUN = get_mode, align = "center", fill = NA),
    
    # Convert smoothed cloud cover to factor with reference "CLR"
    skyc1_rollavg = factor(skyc1_rollavg),
    skyc1_rollavg = relevel(skyc1_rollavg, ref = "CLR"),
    
    # Calculate decimal exit time
    decimal_exit_time = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60,
    
    # Circular time variables for circadian effect
    time_rad = (decimal_exit_time / 24) * 2 * pi,
    sin_time = sin(time_rad),
    cos_time = cos(time_rad),
    
    # Time difference between bee exit and ground temp measurement
    time_diff_ground = abs(difftime(bee_exit_datetime, datetime_ground_temp, units = "mins"))
  ) %>%
  filter(
    # Keep only rows where bee exit time and temp are closely matched (within 15 minutes)
    time_diff_ground <= 15,
    !is.na(ground_temp_rollavg),
    !is.na(tmpf_rollavg),
    !is.na(relh_rollavg),
    !is.na(skyc1_rollavg)
  )

# Fit the model with smoothed variables and circular time terms
model_all_vars_smoothed <- lm(
  decimal_exit_time ~ sin_time + cos_time + ground_temp_rollavg + tmpf_rollavg + relh_rollavg + skyc1_rollavg,
  data = joined_bee_ws_gt_data_analysis
)

summary(model_all_vars_smoothed)

```

```{r}
#re-run multiple step linear regression with raw un-smoothed data

library(dplyr)
library(lubridate)

# Prepare the dataset without smoothing
joined_bee_ws_gt_data_analysis_raw <- joined_bee_ws_gt_data %>%
  mutate(
    # Convert cloud cover to factor with reference level "CLR"
    skyc1_factor = factor(skyc1),
    skyc1_factor = relevel(skyc1_factor, ref = "CLR"),
    
    # Decimal exit time
    decimal_exit_time = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60,
    
    # Circular time variables
    time_rad = (decimal_exit_time / 24) * 2 * pi,
    sin_time = sin(time_rad),
    cos_time = cos(time_rad)
    )

# Fit the model with raw variables
model_all_vars_raw <- lm(
  decimal_exit_time ~ sin_time + cos_time + ground_temperature_F + tmpf + relh + skyc1_factor,
  data = joined_bee_ws_gt_data_analysis_raw
)

# View summary
summary(model_all_vars_raw)



#re-run step-wise regression with time as a variable and time as a predictor variable

# Extract decimal time of day
joined_bee_ws_gt_data <- joined_bee_ws_gt_data %>%
  mutate(
    decimal_exit_time = hour(bee_exit_datetime) + minute(bee_exit_datetime) / 60,
    time_radians = 2 * pi * decimal_exit_time / 24,
    sin_time = sin(time_radians),
    cos_time = cos(time_radians),
    skyc1_factor = as.factor(skyc1),
    skyc1_factor = relevel(skyc1_factor, ref = "CLR") 
  )

# Prepare the full model
full_model <- lm(decimal_exit_time ~ sin_time + cos_time + ground_temperature_F + tmpf + relh + skyc1_factor,
                 data = joined_bee_ws_gt_data)

# Run stepwise regression using AIC
stepwise_model <- stepAIC(full_model, direction = "both", trace = FALSE)

# Summarize the final model
summary(stepwise_model)



```





```{r}
#graph to plot time vs. emergence and show cloud cover

library(dplyr)
library(ggplot2)
library(lubridate)

# Make sure bee_exit_datetime is in POSIXct format
# And skyc1 is a factor (optional, but good for controlling color order)
emergence_plot <- joined_bee_ws_gt_data %>%
  mutate(
    time_of_day = format(bee_exit_datetime, format = "%H:%M:%S"),
    time_of_day = as.POSIXct(time_of_day, format = "%H:%M:%S"),
    skyc1 = factor(skyc1, levels = c("CLR", "FEW", "SCT", "BKN", "OVC"))
  )

# Create plot
ggplot(emergence_plot, aes(x = time_of_day, y = 1, color = skyc1)) +
  geom_point(position = position_jitter(height = 0.1), size = 2, alpha = 0.7) +
  scale_x_datetime(
    name = "Time of Day",
    breaks = seq(from = as.POSIXct("07:00:00", format = "%H:%M:%S"),
                 to = as.POSIXct("17:00:00", format = "%H:%M:%S"),
                 by = "30 mins"),
    date_labels = "%H:%M"
  ) +
  scale_y_continuous(NULL, breaks = NULL) +  # Hide Y axis
  scale_color_manual(
    values = c("CLR" = "#FDB813", "FEW" = "#A8DADC", "SCT" = "#457B9D", 
               "BKN" = "#1D3557", "OVC" = "#6C757D")
  ) +
  labs(
    title = "Individual Bee Emergence Times by Cloud Cover",
    color = "Cloud Cover"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```
```{r}
#R-script to make three models to see whether time or climate factors better predicts bee-activity.


# Load libraries
library(dplyr)
library(lubridate)
library(MASS)
install.packages("car")
library(car)
install.packages("relaimpo")
library(relaimpo)
install.packages("lme4")
library(lme4)

# Prepare the data
bee_model_data <- joined_bee_ws_gt_data %>%
  mutate(
    Date = as.Date(bee_exit_datetime),
    exit_hour = hour(bee_exit_datetime) + minute(bee_exit_datetime)/60,
    time_radians = 2 * pi * exit_hour / 24,
    sin_time = sin(time_radians),
    cos_time = cos(time_radians),
    skyc1 = as.factor(skyc1)
  ) %>%
  filter(!is.na(exit_hour), !is.na(tmpf), !is.na(ground_temperature_F), !is.na(relh), !is.na(skyc1))

bee_model_data$skyc1 <- relevel(bee_model_data$skyc1, ref = "CLR")

# Model 1: Climate-only (no time)
climate_model <- lm(exit_hour ~ ground_temperature_F + tmpf + relh + skyc1, data = bee_model_data)

# Model 2: Time + Climate (regular linear model)
time_climate_model <- lm(exit_hour ~ sin_time + cos_time + ground_temperature_F + tmpf + relh + skyc1, 
                         data = bee_model_data)

# Model 3: Time + Climate + Random Intercept for Day
time_climate_mixed <- lmer(exit_hour ~ sin_time + cos_time + ground_temperature_F + tmpf + relh + skyc1 + 
                           (1 | Date), data = bee_model_data, REML = FALSE)

# --- Model Comparisons ---
# AIC values
cat("AIC values:\n")
AIC(climate_model, time_climate_model, time_climate_mixed)

# ANOVA between climate-only and time+climate
cat("\nANOVA: Does time add explanatory power?\n")
anova(climate_model, time_climate_model)

# Variance Partitioning (only works on lm objects)
cat("\nRelative Importance of Predictors (LM only):\n")
calc.relimp(time_climate_model, type = "lmg")

# Summary of Mixed Model
cat("\nSummary of Mixed Model:\n")
summary(time_climate_mixed)



```
```{r}
#visualizing which models best predicts bee exit time:

library(ggplot2)

library(dplyr)
library(ggplot2)
library(tidyr)

# Ensure predictions exist
bee_model_data <- bee_model_data %>%
  mutate(
    pred_climate = predict(climate_model),
    pred_time_climate = predict(time_climate_model),
    pred_mixed = predict(time_climate_mixed)
  )

# Create a new tibble for plotting (to avoid issues from masking)
plot_data <- bee_model_data %>%
  dplyr::select(exit_hour, pred_climate, pred_time_climate, pred_mixed) %>%
  tidyr::pivot_longer(
    cols = starts_with("pred_"),
    names_to = "model",
    values_to = "predicted_exit"
  ) %>%
  dplyr::mutate(model = dplyr::recode(model,
    "pred_climate" = "Climate Only (LM)",
    "pred_time_climate" = "Time + Climate (LM)",
    "pred_mixed" = "Time + Climate + Day (Mixed)"
  ))

# Plot
ggplot(plot_data, aes(x = exit_hour, y = predicted_exit, color = model)) +
  geom_point(alpha = 0.4, size = 2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") +
  facet_wrap(~model) +
  labs(
    title = "Observed vs. Predicted Bee Exit Hour",
    x = "Observed Exit Hour",
    y = "Predicted Exit Hour",
    color = "Model"
  ) +
  theme_minimal()

```


```{r}
#further analysis of plots and code to explore whether circadian rhythm interacts with sky conditions: does cloud cover shift or flatten rhythm?

# Update the mixed-effects model to include interaction
interaction_model <- lmer(
  exit_hour ~ sin_time * skyc1 + cos_time + ground_temperature_F + tmpf + relh + (1 | Date),
  data = bee_model_data,
  REML = FALSE
)

summary(interaction_model)


#lets plot this interaction:
library(ggplot2)
library(dplyr)

# 1. Create a sequence of exit hours (7 AM to 5 PM in 0.1 hour steps)
hour_seq <- seq(7, 17, length.out = 100)

# 2. Create new data frame with sin/cos transformations and repeated skyc1 levels
new_data <- expand.grid(
  exit_hour = hour_seq,
  skyc1 = levels(bee_model_data$skyc1)
) %>%
  mutate(
    time_radians = 2 * pi * exit_hour / 24,
    sin_time = sin(time_radians),
    cos_time = cos(time_radians),
    ground_temperature_F = mean(bee_model_data$ground_temperature_F, na.rm = TRUE),
    tmpf = mean(bee_model_data$tmpf, na.rm = TRUE),
    relh = mean(bee_model_data$relh, na.rm = TRUE)
  )

# 3. Predict using the interaction model
new_data$predicted_exit <- predict(interaction_model, newdata = new_data, re.form = NA)

new_data <- new_data %>%
  mutate(deviation = predicted_exit - exit_hour)

ggplot(new_data, aes(x = exit_hour, y = deviation, color = skyc1)) +
  geom_line(linewidth = 1.0) +
  labs(
    title = "Effect of Sky Condition on Timing of Bee Emergence",
    x = "Time of Day (Hour)",
    y = "Deviation from Baseline Exit Hour",
    color = "Sky Condition"
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  theme_minimal()


```
```{r}

#okay back to the drawing board: this code will attempt to put each bee exit in 15 minute time blocks to further categorize them and count how many bees exited in each block to add to analysis. This will answer: "when do bees tend to emerge and what conditions correlate with higher emergence counts" 

library(dplyr)
library(lubridate)

# Add a 15-minute time block column to each bee
joined_bee_ws_gt_data <- joined_bee_ws_gt_data %>%
  mutate(
    time_block = floor_date(bee_exit_datetime, unit = "15 minutes")
  )

# Count how many bees exited in each 15-min block across the dataset
bee_block_counts <- joined_bee_ws_gt_data %>%
  count(time_block, name = "n_exited")

# Join the count back into the original data frame
joined_bee_ws_gt_data <- joined_bee_ws_gt_data %>%
  left_join(bee_block_counts, by = "time_block")

#calculating sin/cos time to convert time into points on a circle to deal with issues related to the cyclical nature of time

joined_bee_ws_gt_data <- joined_bee_ws_gt_data %>%
  mutate(
    decimal_hour = hour(time_block) + minute(time_block) / 60,
    radians = 2 * pi * decimal_hour / 24,
    sin_time = sin(radians),
    cos_time = cos(radians)
  )



lm(decimal_hour ~ tmpf + relh + ground_temperature_F + sin_time + cos_time, data = joined_bee_ws_gt_data)



```

```{r}
#More data cleaning to make bee exits a binomial value
install.packages("FNN")       # For fast nearest-neighbor joins
install.packages("lubridate")

library(dplyr)
library(lubridate)
library(tidyr)
library(FNN)

# Step 1: Round bee exit to time blocks
joined_bee_ws_gt_data <- joined_bee_ws_gt_data %>%
  mutate(
    date = as_date(bee_exit_datetime),
    time_block = floor_date(bee_exit_datetime, unit = "15 minutes"),
    bee_exited = 1
  )

# Make sure datetime columns are properly formatted
joined_bee_ws_gt_data <- joined_bee_ws_gt_data %>%
  mutate(
    bee_exit_datetime = as.POSIXct(bee_exit_datetime, tz = "UTC"),  # or your actual TZ
    date = as_date(bee_exit_datetime)
  )

# When generating time blocks, explicitly specify the time zone too
all_time_blocks <- joined_bee_ws_gt_data %>%
  distinct(date) %>%
  rowwise() %>%
  mutate(time_seq = list(seq.POSIXt(
    from = as.POSIXct(paste(date, "07:00:00"), tz = "UTC"),
    to   = as.POSIXct(paste(date, "17:00:00"), tz = "UTC"),
    by   = "15 min"
  ))) %>%
  unnest(time_seq) %>%
  rename(time_block = time_seq)



# Step 2: Build full sequence of 15-min blocks (from 07:00 to 17:00)
all_time_blocks <- joined_bee_ws_gt_data %>%
  distinct(date) %>%
  rowwise() %>%
  mutate(time_seq = list(seq.POSIXt(
    from = as.POSIXct(paste(date, "07:00:00")),
    to   = as.POSIXct(paste(date, "17:00:00")),
    by   = "15 min"
  ))) %>%
  unnest(time_seq) %>%
  rename(time_block = time_seq)

# Step 3: Mark whether any bee exited in each block
bee_block_data <- all_time_blocks %>%
  left_join(
    joined_bee_ws_gt_data %>%
      select(date, time_block, bee_exited),
    by = c("date", "time_block")
  ) %>%
  mutate(bee_exited = ifelse(is.na(bee_exited), 0, bee_exited))

# Step 4: Nearest weather reading per block
# Prepare matching data
block_times <- bee_block_data %>%
  mutate(block_time_numeric = as.numeric(time_block))

weather_obs <- joined_bee_ws_gt_data %>%
  select(date, obs_time = bee_exit_datetime, tmpf, relh, ground_temperature_F, skyc1) %>%
  distinct() %>%
  mutate(obs_time_numeric = as.numeric(obs_time))

# Nearest neighbor match (1-NN)
nearest_idx <- get.knnx(
  data = matrix(weather_obs$obs_time_numeric),
  query = matrix(block_times$block_time_numeric),
  k = 1
)$nn.index[,1]

# Add nearest weather obs
bee_block_data <- bind_cols(
  bee_block_data,
  weather_obs[nearest_idx, c("tmpf", "relh", "ground_temperature_F", "skyc1")]
)

# Step 5: Add time-based predictors
bee_block_data <- bee_block_data %>%
  mutate(
    decimal_hour = hour(time_block) + minute(time_block) / 60,
    time_rad = 2 * pi * decimal_hour / 24,
    sin_time = sin(time_rad),
    cos_time = cos(time_rad),
    skyc1 = as.factor(skyc1),
    skyc1 = relevel(skyc1, ref = "CLR")
  )



```

